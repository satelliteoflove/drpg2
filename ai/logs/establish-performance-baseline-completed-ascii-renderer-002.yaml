node_id: establish-performance-baseline
checklist:
  unit_tests: false
  integration_tests: false
  e2e_tests: false
outcome: |
  Successfully implemented a comprehensive performance monitoring system that tracks FPS, render times, 
  update times, and memory usage across all game scenes. Created PerformanceMonitor utility class with 
  automated scene-based tracking, rolling averages, percentile calculations, and markdown report generation. 
  Integrated monitoring into the game loop and added user-accessible command to generate performance reports.
  
  Baseline Performance Captured:
  - Performance Score: 83.2/100 (Acceptable)
  - Average FPS across scenes: 63-74 FPS
  - Minimum FPS: 29.4 (just below 30 FPS threshold)
  - Frame drop rate: 56.1% (frames below 60 FPS)
  - All scenes generally meeting performance targets
  - Fixed infinity FPS calculation issue with proper bounds checking
manual_test_instructions: |
  1. Start the development server with 'npm run dev'
  2. Open the game in Chrome or Edge browser (for memory monitoring)
  3. Navigate through each scene in sequence:
     - Main Menu (loads automatically)
     - New Game (select from menu)
     - Character Creation (create 6 characters)
     - Town Scene (after character creation)
     - Shop Scene (enter Boltac's from town)
     - Dungeon Scene (enter dungeon from town)
     - Combat Scene (press 'T' in dungeon for test combat)
     - Inventory Scene (press 'I' in dungeon)
  4. Spend at least 30 seconds in each scene to gather metrics
  5. Press 'D' to open Debug Scene from any location
  6. Press 'P' to generate the performance report
  7. Check browser console for the formatted performance report
  8. Verify the report shows:
     - Per-scene FPS metrics (avg, min, max, percentiles)
     - Render and update times
     - Memory usage (if supported)
     - Overall performance score (0-100)
surprises_or_notes: |
  - Memory monitoring is only available in Chromium-based browsers (Chrome, Edge) due to performance.memory API
  - The DebugLogger uses static methods rather than instance methods, requiring adjustment from initial design
  - Scene change notifications are handled via callback pattern for loose coupling
  - Performance score calculation uses weighted average of FPS score (70%) and stability score (30%)
suggested_follow_ups:
  - Run performance baseline tests on different hardware configurations
  - Create automated performance regression tests
  - Add performance budget alerts when metrics drop below thresholds
  - Implement performance data persistence for historical tracking
  - Add visual performance overlay option for real-time monitoring
reimplementation_prompt: |
  Implement a performance monitoring system for a TypeScript/Canvas game engine.

  Requirements:
  - Track per-scene performance metrics (FPS, render time, update time, memory)
  - Calculate rolling averages with 60-frame window
  - Support percentile calculations (95th, 99th)
  - Generate markdown-formatted performance reports
  - Integrate with game loop for accurate timing
  - Track scene transitions automatically
  - Provide keyboard command to generate reports

  Key design decisions:
  - Use singleton pattern for PerformanceMonitor class
  - Mark timing phases (update start/end, render start/end) in game loop
  - Use performance.now() for high-resolution timestamps
  - Calculate performance score as weighted average: 70% FPS, 30% stability
  - Store metrics per scene with automatic scene change detection
  - Export reports as markdown for documentation purposes
  - Target 60 FPS with 30 FPS minimum acceptable threshold

  Implementation should use TypeScript strict mode and avoid external dependencies.