<!DOCTYPE html>
<html>
<head>
    <title>Phase 1 Magic Testing - Damage & Healing</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #0f0; }
        .section { margin: 20px 0; padding: 10px; border: 1px solid #0f0; }
        .pass { color: #0f0; }
        .fail { color: #f00; }
        .info { color: #ff0; }
        button { padding: 10px; margin: 5px; background: #333; color: #0f0; border: 1px solid #0f0; cursor: pointer; }
        button:hover { background: #0f0; color: #000; }
        #results { white-space: pre-wrap; }
    </style>
</head>
<body>
    <h1>Phase 1 Magic System Testing</h1>
    <div class="section">
        <h2>Test Controls</h2>
        <button onclick="testSpellRegistry()">Test Spell Registry</button>
        <button onclick="testDamageSpells()">Test Damage Spells</button>
        <button onclick="testHealingSpells()">Test Healing Spells</button>
        <button onclick="testInCombat()">Test Combat Casting</button>
        <button onclick="navigateToCombat()">Navigate to Combat</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>
    <div class="section">
        <h2>Test Results</h2>
        <div id="results"></div>
    </div>
    <iframe id="game" src="http://localhost:8080" width="100%" height="600" style="border: 1px solid #0f0;"></iframe>

    <script>
        const results = document.getElementById('results');
        const gameFrame = document.getElementById('game');
        let gameWindow = null;

        gameFrame.onload = () => {
            gameWindow = gameFrame.contentWindow;
            log('Game loaded. Waiting for AI interface...', 'info');

            setTimeout(() => {
                if (gameWindow.AI) {
                    log('AI interface ready!', 'pass');
                    log(`Current scene: ${gameWindow.AI.getScene()}`, 'info');
                } else {
                    log('AI interface not found!', 'fail');
                }
            }, 1000);
        };

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'pass' ? 'pass' : type === 'fail' ? 'fail' : 'info';
            results.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
            results.scrollTop = results.scrollHeight;
        }

        function clearResults() {
            results.innerHTML = '';
            log('Results cleared', 'info');
        }

        function testSpellRegistry() {
            if (!gameWindow?.SpellRegistry) {
                log('SpellRegistry not available', 'fail');
                return;
            }

            try {
                const registry = gameWindow.SpellRegistry.getInstance();
                const allSpells = registry.getAllSpells();
                log(`Total spells registered: ${allSpells.length}`, 'info');

                const damageSpells = allSpells.filter(s => s.effects?.some(e => e.type === 'damage'));
                const healingSpells = allSpells.filter(s => s.effects?.some(e => e.type === 'heal'));

                log(`Damage spells: ${damageSpells.length}`, 'info');
                log(`Healing spells: ${healingSpells.length}`, 'info');

                if (damageSpells.length > 0) {
                    log(`Sample damage spell: ${damageSpells[0].name} (${damageSpells[0].id})`, 'pass');
                }
                if (healingSpells.length > 0) {
                    log(`Sample healing spell: ${healingSpells[0].name} (${healingSpells[0].id})`, 'pass');
                }

                const flameDart = registry.getSpellById('m1_flame_dart');
                if (flameDart) {
                    log(`Flame Dart found: MP Cost ${flameDart.mpCost}, Level ${flameDart.level}`, 'pass');
                } else {
                    log('Flame Dart (m1_flame_dart) not found!', 'fail');
                }

                const heal = registry.getSpellById('p1_heal');
                if (heal) {
                    log(`Heal found: MP Cost ${heal.mpCost}, Level ${heal.level}`, 'pass');
                } else {
                    log('Heal (p1_heal) not found!', 'fail');
                }

            } catch (error) {
                log(`Registry test error: ${error.message}`, 'fail');
            }
        }

        function testDamageSpells() {
            if (!gameWindow?.AI) {
                log('AI interface not available', 'fail');
                return;
            }

            try {
                const party = gameWindow.AI.getParty();
                if (!party?.characters?.length) {
                    log('No party available. Navigate to game first.', 'fail');
                    return;
                }

                const mage = party.characters.find(c => c.class === 'Mage' || c.knownSpells?.includes('m1_flame_dart'));
                if (mage) {
                    log(`Found spellcaster: ${mage.name} (${mage.class})`, 'pass');
                    log(`Known spells: ${mage.knownSpells?.join(', ') || 'none'}`, 'info');
                    log(`MP: ${mage.mp.current}/${mage.mp.max}`, 'info');
                } else {
                    log('No mage or character with damage spells found', 'fail');
                }

                const combat = gameWindow.AI.getCombat();
                if (combat?.inCombat) {
                    log('In combat - damage spells should be castable', 'pass');
                    if (combat.enemies?.length > 0) {
                        log(`Enemies available: ${combat.enemies.length}`, 'info');
                        const enemy = combat.enemies[0];
                        log(`Target: ${enemy.name} HP: ${enemy.hp}/${enemy.maxHp}`, 'info');
                    }
                } else {
                    log('Not in combat - damage spells may be restricted', 'info');
                }

            } catch (error) {
                log(`Damage spell test error: ${error.message}`, 'fail');
            }
        }

        function testHealingSpells() {
            if (!gameWindow?.AI) {
                log('AI interface not available', 'fail');
                return;
            }

            try {
                const party = gameWindow.AI.getParty();
                if (!party?.characters?.length) {
                    log('No party available. Navigate to game first.', 'fail');
                    return;
                }

                const priest = party.characters.find(c => c.class === 'Priest' || c.knownSpells?.includes('p1_heal'));
                if (priest) {
                    log(`Found healer: ${priest.name} (${priest.class})`, 'pass');
                    log(`Known spells: ${priest.knownSpells?.join(', ') || 'none'}`, 'info');
                    log(`MP: ${priest.mp.current}/${priest.mp.max}`, 'info');
                } else {
                    log('No priest or character with healing spells found', 'fail');
                }

                party.characters.forEach(char => {
                    if (char.hp.current < char.hp.max) {
                        log(`${char.name} needs healing: ${char.hp.current}/${char.hp.max}`, 'info');
                    }
                });

            } catch (error) {
                log(`Healing spell test error: ${error.message}`, 'fail');
            }
        }

        async function navigateToCombat() {
            if (!gameWindow?.AI) {
                log('AI interface not available', 'fail');
                return;
            }

            try {
                const currentScene = gameWindow.AI.getScene();
                log(`Current scene: ${currentScene}`, 'info');

                if (currentScene === 'MainMenu') {
                    log('Starting new game...', 'info');
                    gameWindow.AI.sendKey('Enter');
                    await sleep(500);
                    gameWindow.AI.sendKey('ArrowDown');
                    await sleep(200);
                    gameWindow.AI.sendKey('Enter');
                    await sleep(500);
                    gameWindow.AI.sendKey('Enter');
                    await sleep(1000);
                }

                if (gameWindow.AI.getScene() === 'Dungeon' || gameWindow.AI.getScene()?.toLowerCase() === 'dungeon') {
                    log('In dungeon, moving to trigger combat...', 'info');
                    for (let i = 0; i < 10; i++) {
                        gameWindow.AI.sendKey('ArrowUp');
                        await sleep(100);
                        if (gameWindow.AI.getScene() === 'Combat') {
                            log('Combat triggered!', 'pass');
                            const combat = gameWindow.AI.getCombat();
                            log(`Enemies: ${combat.enemies?.length || 0}`, 'info');
                            return;
                        }
                    }
                    log('Could not trigger combat after 10 moves', 'fail');
                } else {
                    log(`Not in dungeon. Current scene: ${gameWindow.AI.getScene()}`, 'fail');
                }

            } catch (error) {
                log(`Navigation error: ${error.message}`, 'fail');
            }
        }

        async function testInCombat() {
            if (!gameWindow?.AI) {
                log('AI interface not available', 'fail');
                return;
            }

            try {
                const scene = gameWindow.AI.getScene();
                if (scene !== 'Combat') {
                    log('Not in combat. Navigate to combat first.', 'fail');
                    return;
                }

                const combat = gameWindow.AI.getCombat();
                const party = gameWindow.AI.getParty();

                log('=== Combat Spell Test ===', 'info');
                log(`Current character: ${combat.currentCharacter}`, 'info');

                const currentChar = party.characters[combat.currentCharacter || 0];
                if (currentChar) {
                    log(`${currentChar.name} (${currentChar.class})`, 'info');
                    log(`Spells: ${currentChar.knownSpells?.join(', ') || 'none'}`, 'info');
                    log(`MP: ${currentChar.mp.current}/${currentChar.mp.max}`, 'info');

                    if (currentChar.knownSpells?.length > 0) {
                        log('Opening spell menu (press M)...', 'info');
                        gameWindow.AI.sendKey('m');
                        await sleep(500);

                        const afterMenu = gameWindow.AI.getCombat();
                        if (afterMenu.spellMenuOpen) {
                            log('Spell menu opened!', 'pass');

                            log('Selecting first spell (press 1)...', 'info');
                            gameWindow.AI.sendKey('1');
                            await sleep(500);

                            const afterSelect = gameWindow.AI.getCombat();
                            if (afterSelect.targetSelectionActive) {
                                log('Target selection active!', 'pass');
                                log(`Selected target: ${afterSelect.selectedTarget}`, 'info');

                                log('Casting spell (press Enter)...', 'info');
                                gameWindow.AI.sendKey('Enter');
                                await sleep(1000);

                                const afterCast = gameWindow.AI.getCombat();
                                const newChar = gameWindow.AI.getParty().characters[combat.currentCharacter || 0];
                                if (newChar.mp.current < currentChar.mp.current) {
                                    log(`Spell cast! MP used: ${currentChar.mp.current - newChar.mp.current}`, 'pass');
                                } else {
                                    log('MP not consumed - spell may have fizzled or failed', 'fail');
                                }
                            } else {
                                log('Target selection did not activate', 'fail');
                            }
                        } else {
                            log('Spell menu did not open', 'fail');
                        }
                    } else {
                        log('Current character has no spells', 'info');
                    }
                }

            } catch (error) {
                log(`Combat test error: ${error.message}`, 'fail');
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>