import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { InputHandler } from '../InputHandler';
import { InputZone } from '../SceneDeclaration';

describe('InputHandler', () => {
  let canvas: HTMLCanvasElement;
  let inputHandler: InputHandler;
  let mockCallback: jest.Mock;

  beforeEach(() => {
    canvas = document.createElement('canvas');
    canvas.width = 800;
    canvas.height = 500;
    document.body.appendChild(canvas);
    
    inputHandler = new InputHandler(canvas, {
      charWidth: 10,
      charHeight: 20
    });
    
    mockCallback = jest.fn();
  });

  afterEach(() => {
    inputHandler.destroy();
    document.body.removeChild(canvas);
    jest.clearAllMocks();
  });

  describe('Initialization', () => {
    it('should initialize with canvas and config', () => {
      expect(inputHandler).toBeDefined();
    });

    it('should handle missing config gracefully', () => {
      const handler = new InputHandler(canvas);
      expect(handler).toBeDefined();
      handler.destroy();
    });
  });

  describe('Input Zone Management', () => {
    it('should set input zones', () => {
      const zones: InputZone[] = [
        {
          id: 'button1',
          bounds: {
              x: 5,
              y: 5,
              width: 10,
              height: 3
          },
          type: 'button',
          enabled: true
        },
        {
          id: 'menu',
          bounds: {
              x: 20,
              y: 10,
              width: 15,
              height: 5
          },
          type: 'menu-item',
          enabled: true
        }
      ];
      
      inputHandler.setInputZones(zones);
      expect(() => inputHandler.setInputZones(zones)).not.toThrow();
    });

    it('should clear zones when empty array provided', () => {
      const zones: InputZone[] = [{
        id: 'test',
        bounds: {
          bounds: {
            x: 0,
            y: 0,
            width: 10,
            height: 10
          },
        },
        type: 'button',
        enabled: true
      }];
      
      inputHandler.setInputZones(zones);
      inputHandler.setInputZones([]);
      
      const focusedZone = inputHandler.getFocusedZone();
      expect(focusedZone).toBeNull();
    });

    it('should handle non-interactive zones', () => {
      const zones: InputZone[] = [
        {
          id: 'static',
          bounds: {
              x: 5,
              y: 5,
              width: 10,
              height: 3
          },
          type: 'custom',
          enabled: false
        }
      ];
      
      inputHandler.setInputZones(zones);
      expect(() => inputHandler.setInputZones(zones)).not.toThrow();
    });
  });

  describe('Mouse Events', () => {
    beforeEach(() => {
      const zones: InputZone[] = [
        {
          id: 'button1',
          bounds: {
              x: 5,
              y: 5,
              width: 10,
              height: 3
          },
          type: 'button',
          enabled: true
        },
        {
          id: 'button2',
          bounds: {
              x: 20,
              y: 5,
              width: 10,
              height: 3
          },
          type: 'button',
          enabled: true
        }
      ];
      inputHandler.setInputZones(zones);
    });

    it('should handle click events on zones', () => {
      inputHandler.addEventListener('click', mockCallback);
      
      const clickEvent = new MouseEvent('click', {
        clientX: 55,
        clientY: 110,
        bubbles: true
      });
      
      canvas.getBoundingClientRect = jest.fn(() => ({
        left: 0,
        top: 0,
        right: 800,
        bottom: 500,
        width: 800,
        height: 500,
        x: 0,
        y: 0,
        toJSON: () => ({})
      }));
      
      canvas.dispatchEvent(clickEvent);
      
      expect(mockCallback).toHaveBeenCalled();
      expect(mockCallback.mock.calls[0][0]).toHaveProperty('zone');
    });

    it('should handle hover events', () => {
      inputHandler.addEventListener('hover', mockCallback);
      
      const moveEvent = new MouseEvent('mousemove', {
        clientX: 55,
        clientY: 110,
        bubbles: true
      });
      
      canvas.getBoundingClientRect = jest.fn(() => ({
        left: 0,
        top: 0,
        right: 800,
        bottom: 500,
        width: 800,
        height: 500,
        x: 0,
        y: 0,
        toJSON: () => ({})
      }));
      
      canvas.dispatchEvent(moveEvent);
      
      expect(mockCallback).toHaveBeenCalled();
    });

    it('should handle mouse leave events', () => {
      inputHandler.addEventListener('hover', mockCallback);
      
      const moveEvent1 = new MouseEvent('mousemove', {
        clientX: 55,
        clientY: 110,
        bubbles: true
      });
      
      const moveEvent2 = new MouseEvent('mousemove', {
        clientX: 300,
        clientY: 300,
        bubbles: true
      });
      
      canvas.getBoundingClientRect = jest.fn(() => ({
        left: 0,
        top: 0,
        right: 800,
        bottom: 500,
        width: 800,
        height: 500,
        x: 0,
        y: 0,
        toJSON: () => ({})
      }));
      
      canvas.dispatchEvent(moveEvent1);
      canvas.dispatchEvent(moveEvent2);
      
      expect(mockCallback).toHaveBeenCalled();
    });

    it('should ignore clicks on non-interactive zones', () => {
      const zones: InputZone[] = [
        {
          id: 'static',
          bounds: {
              x: 5,
              y: 5,
              width: 10,
              height: 3
          },
          type: 'custom',
          enabled: false
        }
      ];
      inputHandler.setInputZones(zones);
      inputHandler.addEventListener('click', mockCallback);
      
      const clickEvent = new MouseEvent('click', {
        clientX: 55,
        clientY: 110,
        bubbles: true
      });
      
      canvas.dispatchEvent(clickEvent);
      
      expect(mockCallback).not.toHaveBeenCalled();
    });
  });

  describe('Keyboard Events', () => {
    it('should handle key bindings', () => {
      inputHandler.addKeyBinding({
        key: 'Enter',
        action: mockCallback
      });
      
      const keyEvent = new KeyboardEvent('keydown', {
        key: 'Enter',
        bubbles: true
      });
      
      document.dispatchEvent(keyEvent);
      
      expect(mockCallback).toHaveBeenCalled();
    });

    it('should handle key bindings with modifiers', () => {
      inputHandler.addKeyBinding({
        key: 's',
        modifiers: { ctrl: true },
        action: mockCallback
      });
      
      const keyEvent = new KeyboardEvent('keydown', {
        key: 's',
        ctrlKey: true,
        bubbles: true
      });
      
      document.dispatchEvent(keyEvent);
      
      expect(mockCallback).toHaveBeenCalled();
    });

    it('should not trigger without required modifiers', () => {
      inputHandler.addKeyBinding({
        key: 's',
        modifiers: { ctrl: true },
        action: mockCallback
      });
      
      const keyEvent = new KeyboardEvent('keydown', {
        key: 's',
        ctrlKey: false,
        bubbles: true
      });
      
      document.dispatchEvent(keyEvent);
      
      expect(mockCallback).not.toHaveBeenCalled();
    });

    it('should remove key bindings', () => {
      inputHandler.addKeyBinding({
        key: 'Escape',
        action: mockCallback
      });
      
      inputHandler.removeKeyBinding('Escape');
      
      const keyEvent = new KeyboardEvent('keydown', {
        key: 'Escape',
        bubbles: true
      });
      
      document.dispatchEvent(keyEvent);
      
      expect(mockCallback).not.toHaveBeenCalled();
    });

    it('should handle multiple bindings for different keys', () => {
      const callback1 = jest.fn();
      const callback2 = jest.fn();
      
      inputHandler.addKeyBinding({
        key: 'a',
        action: callback1
      });
      
      inputHandler.addKeyBinding({
        key: 'b',
        action: callback2
      });
      
      const keyEventA = new KeyboardEvent('keydown', {
        key: 'a',
        bubbles: true
      });
      
      const keyEventB = new KeyboardEvent('keydown', {
        key: 'b',
        bubbles: true
      });
      
      document.dispatchEvent(keyEventA);
      expect(callback1).toHaveBeenCalled();
      expect(callback2).not.toHaveBeenCalled();
      
      callback1.mockClear();
      
      document.dispatchEvent(keyEventB);
      expect(callback1).not.toHaveBeenCalled();
      expect(callback2).toHaveBeenCalled();
    });
  });

  describe('Zone Navigation', () => {
    beforeEach(() => {
      const zones: InputZone[] = [
        {
          id: 'zone1',
          bounds: {
              x: 5,
              y: 5,
              width: 10,
              height: 3
          },
          type: 'button',
          enabled: true,
          navigable: true
        },
        {
          id: 'zone2',
          bounds: {
              x: 5,
              y: 10,
              width: 10,
              height: 3
          },
          type: 'button',
          enabled: true,
          navigable: true
        },
        {
          id: 'zone3',
          bounds: {
              x: 20,
              y: 5,
              width: 10,
              height: 3
          },
          type: 'button',
          enabled: true,
          navigable: true
        }
      ];
      inputHandler.setInputZones(zones);
    });

    it('should navigate between zones', () => {
      inputHandler.setFocusedZone('zone1');
      expect(inputHandler.getFocusedZone()).toBe('zone1');
      
      inputHandler.navigateZones('down');
      expect(inputHandler.getFocusedZone()).toBe('zone2');
      
      inputHandler.navigateZones('up');
      expect(inputHandler.getFocusedZone()).toBe('zone1');
      
      inputHandler.navigateZones('right');
      expect(inputHandler.getFocusedZone()).toBe('zone3');
    });

    it('should wrap navigation at boundaries', () => {
      inputHandler.setFocusedZone('zone3');
      inputHandler.navigateZones('right');
      expect(inputHandler.getFocusedZone()).toBe('zone1');
    });

    it('should skip non-navigable zones', () => {
      const zones: InputZone[] = [
        {
          id: 'zone1',
          bounds: {
              x: 5,
              y: 5,
              width: 10,
              height: 3
          },
          type: 'button',
          enabled: true,
          navigable: true
        },
        {
          id: 'zone2',
          bounds: {
              x: 5,
              y: 10,
              width: 10,
              height: 3
          },
          type: 'custom',
          enabled: false,
          navigable: false
        },
        {
          id: 'zone3',
          bounds: {
              x: 5,
              y: 15,
              width: 10,
              height: 3
          },
          type: 'button',
          enabled: true,
          navigable: true
        }
      ];
      inputHandler.setInputZones(zones);
      
      inputHandler.setFocusedZone('zone1');
      inputHandler.navigateZones('down');
      expect(inputHandler.getFocusedZone()).toBe('zone3');
    });

    it('should emit focus events', () => {
      const focusCallback = jest.fn();
      const blurCallback = jest.fn();
      
      inputHandler.addEventListener('click', focusCallback);
      inputHandler.addEventListener('click', blurCallback);
      
      inputHandler.setFocusedZone('zone1');
      expect(focusCallback).toHaveBeenCalled();
      
      inputHandler.setFocusedZone('zone2');
      expect(blurCallback).toHaveBeenCalled();
      expect(focusCallback).toHaveBeenCalled();
    });
  });

  describe('Event Listeners', () => {
    it('should add and remove event listeners', () => {
      const callback1 = jest.fn();
      const callback2 = jest.fn();
      
      inputHandler.addEventListener('click', callback1);
      inputHandler.addEventListener('click', callback2);
      
      const zones: InputZone[] = [{
        id: 'test',
        x: 5,
        y: 5,
        width: 10,
        height: 3,
        type: 'button',
        enabled: true
      }];
      inputHandler.setInputZones(zones);
      
      const clickEvent = new MouseEvent('click', {
        clientX: 55,
        clientY: 110,
        bubbles: true
      });
      
      canvas.getBoundingClientRect = jest.fn(() => ({
        left: 0,
        top: 0,
        right: 800,
        bottom: 500,
        width: 800,
        height: 500,
        x: 0,
        y: 0,
        toJSON: () => ({})
      }));
      
      canvas.dispatchEvent(clickEvent);
      
      expect(callback1).toHaveBeenCalled();
      expect(callback2).toHaveBeenCalled();
      
      inputHandler.removeEventListener('zoneClick', callback1);
      callback1.mockClear();
      callback2.mockClear();
      
      canvas.dispatchEvent(clickEvent);
      
      expect(callback1).not.toHaveBeenCalled();
      expect(callback2).toHaveBeenCalled();
    });

    it('should handle raw input events', () => {
      const rawClickCallback = jest.fn();
      const rawKeyCallback = jest.fn();
      
      inputHandler.addEventListener('click', rawClickCallback);
      inputHandler.addEventListener('keydown', rawKeyCallback);
      
      const clickEvent = new MouseEvent('click', {
        clientX: 100,
        clientY: 100,
        bubbles: true
      });
      
      const keyEvent = new KeyboardEvent('keydown', {
        key: 'x',
        bubbles: true
      });
      
      canvas.dispatchEvent(clickEvent);
      document.dispatchEvent(keyEvent);
      
      expect(rawClickCallback).toHaveBeenCalled();
      expect(rawKeyCallback).toHaveBeenCalled();
    });
  });

  describe('Coordinate Conversion', () => {
    it('should convert pixel coordinates to grid coordinates', () => {
      const zones: InputZone[] = [{
        id: 'test',
        x: 5,
        y: 5,
        width: 1,
        height: 1,
        type: 'button',
        enabled: true
      }];
      inputHandler.setInputZones(zones);
      
      canvas.getBoundingClientRect = jest.fn(() => ({
        left: 0,
        top: 0,
        right: 800,
        bottom: 500,
        width: 800,
        height: 500,
        x: 0,
        y: 0,
        toJSON: () => ({})
      }));
      
      const clickEvent = new MouseEvent('click', {
        clientX: 50,
        clientY: 100,
        bubbles: true
      });
      
      inputHandler.addEventListener('click', (event) => {
        expect(event.gridX).toBe(5);
        expect(event.gridY).toBe(5);
      });
      
      canvas.dispatchEvent(clickEvent);
    });

    it('should handle canvas offset correctly', () => {
      canvas.getBoundingClientRect = jest.fn(() => ({
        left: 100,
        top: 50,
        right: 900,
        bottom: 550,
        width: 800,
        height: 500,
        x: 100,
        y: 50,
        toJSON: () => ({})
      }));
      
      const zones: InputZone[] = [{
        id: 'test',
        x: 0,
        y: 0,
        width: 10,
        height: 10,
        type: 'button',
        enabled: true
      }];
      inputHandler.setInputZones(zones);
      
      inputHandler.addEventListener('click', mockCallback);
      
      const clickEvent = new MouseEvent('click', {
        clientX: 100,
        clientY: 50,
        bubbles: true
      });
      
      canvas.dispatchEvent(clickEvent);
      
      expect(mockCallback).toHaveBeenCalled();
    });
  });

  describe('Zone Detection', () => {
    it('should detect overlapping zones correctly', () => {
      const zones: InputZone[] = [
        {
          id: 'bottom',
          bounds: {
              x: 5,
              y: 5,
              width: 10,
              height: 10
          },
          type: 'custom',
          enabled: true,
          priority: 1
        },
        {
          id: 'top',
          bounds: {
              x: 7,
              y: 7,
              width: 5,
              height: 5
          },
          type: 'button',
          enabled: true,
          priority: 2
        }
      ];
      inputHandler.setInputZones(zones);
      
      inputHandler.addEventListener('click', (event) => {
        expect(event.zone?.id).toBe('top');
      });
      
      canvas.getBoundingClientRect = jest.fn(() => ({
        left: 0,
        top: 0,
        right: 800,
        bottom: 500,
        width: 800,
        height: 500,
        x: 0,
        y: 0,
        toJSON: () => ({})
      }));
      
      const clickEvent = new MouseEvent('click', {
        clientX: 80,
        clientY: 160,
        bubbles: true
      });
      
      canvas.dispatchEvent(clickEvent);
    });

    it('should handle zones at grid boundaries', () => {
      const zones: InputZone[] = [
        {
          id: 'edge',
          bounds: {
              x: 79,
              y: 24,
              width: 1,
              height: 1
          },
          type: 'button',
          enabled: true
        }
      ];
      inputHandler.setInputZones(zones);
      
      expect(() => inputHandler.setInputZones(zones)).not.toThrow();
    });
  });

  describe('Cleanup', () => {
    it('should remove all event listeners on destroy', () => {
      const callback = jest.fn();
      inputHandler.addEventListener('click', callback);
      
      inputHandler.destroy();
      
      const clickEvent = new MouseEvent('click', {
        clientX: 55,
        clientY: 110,
        bubbles: true
      });
      
      canvas.dispatchEvent(clickEvent);
      
      expect(callback).not.toHaveBeenCalled();
    });

    it('should clear all zones on destroy', () => {
      const zones: InputZone[] = [{
        id: 'test',
        x: 5,
        y: 5,
        width: 10,
        height: 3,
        type: 'button',
        enabled: true
      }];
      inputHandler.setInputZones(zones);
      
      inputHandler.destroy();
      
      expect(inputHandler.getFocusedZone()).toBeNull();
    });

    it('should remove keyboard listeners on destroy', () => {
      const callback = jest.fn();
      inputHandler.addKeyBinding({
        key: 'Enter',
        action: callback
      });
      
      inputHandler.destroy();
      
      const keyEvent = new KeyboardEvent('keydown', {
        key: 'Enter',
        bubbles: true
      });
      
      document.dispatchEvent(keyEvent);
      
      expect(callback).not.toHaveBeenCalled();
    });
  });
});